# Walkthrough notes

## Step 1: Bootstrapping our UI5 application

Before we can do something with SAPUI5, we need to load and initialize it. \
This process of loading and initializing SAPUI5 is called **bootstrapping**.

## Step 2: Controls

SAPUI5 Controls are used to define appearance and behavior of parts of the screen. \
All controls of SAPUI5 have a fixed set of properties, aggregations, and associations for configuration. \
You can find their descriptions in the [Demo Kit](https://sapui5.hana.ondemand.com/#/api).

## Step 3: XML Views

SAPUI5 supports multiple view types (XML, HTML, JavaScript). \
We choose XML as this produces the most readable code and will force us to separate the view declaration from the controller logic.

## Step 4: Controllers

A view does not necessarily need an explicitly assigned controller. \
You do not have to create a controller if the view is just displaying information and no additional functionality is required. \
If a controller is specified, it is instantiated after the view is loaded.

In SAPUI5, resources are often referred to as modules.

We add an init function to the controller. \
`onInit` is one of SAPUI5’s lifecycle methods that is invoked by the framework when the controller is created, similar to a constructor function of a control.

For more information please refer to [this](https://blogs.sap.com/2018/11/12/sapui5-controller-lifecycle-methods-explained/) blog post.

## Step 9: Component Configuration

Components are independent and reusable parts used in SAPUI5 applications. \
This architectural change allows our app to be used in more flexible environments than our static **index.html** page, such as in a surrounding container like the SAP Fiori launchpad.

## Step 10: Descriptor for Applications

All application-specific configuration settings will now further be put in a separate descriptor file called **manifest.json** \
This clearly separates the application coding from the configuration settings and makes our app even more flexible. \
For example, all SAP Fiori applications are realized as components and come with a descriptor file in order to be hosted in the SAP Fiori launchpad.

The content of the **manifest.json** file is a configuration object in JSON format that contains all global application settings and parameters. \
The manifest file is called the descriptor for applications, components, and libraries and is also referred to as “descriptor” or “app descriptor” when used for applications. \
There are three important sections defined by namespaces in the manifest.json file:
* **sap.app**
* **sap.ui**
* **sap.ui5**

Automatic model instantiation is only available as of SAPUI5 version 1.30.

## Step 11: Pages and Panels

After all the work on the app structure it’s time to improve the look of our app. \
We will use two controls from the **sap.m** library to add a bit more "bling" to our UI. You will also learn about control aggregations in this step.

## Step 12: Shell Control as Container

Now we use a shell control as container for our app and use it as our new root element. The shell takes care of visual adaptation of the application to the device’s screen size by introducing a so-called letterbox on desktop screens. \
The app is now run in a shell that limits the app width. \
There are further options to customize the shell, like setting a custom background image or color and setting a custom logo. Check the related [API reference](https://sapui5.hana.ondemand.com/#/api/sap.m.Shell) for more details.

## Step 13: Margins and Paddings

Instead of manually adding CSS to the controls, we will use the standard classes provided by SAPUI5. \
These classes take care of consistent sizing steps, left-to-right support, and responsiveness. \
Margins can be added to all kinds of controls and are available in many different options.

## Step 14: Custom CSS and Theme Colors

Sometimes we need to define some more fine-granular layouts and this is when we can use the flexibility of CSS by adding custom style classes to controls and style them as we like.

⛔️ As stated in the *Compatibility Rules*, the HTML and CSS generated by SAPUI5 is not part of the public API and may change in patch and minor releases. \
If you decide to override styles, you need to test and update your modifications each time SAPUI5 is updated.

In a new style definition file inside the css folder we create our custom classes combined with a custom namespace class.

For a complete list of the available CSS class names, see [CSS Classes for Theme Parameters](https://sapui5.hana.ondemand.com/#/topic/ea08f53503da42c19afd342f4b0c9ec7.html).

## Step 15: Nested Views

Instead of putting the panel and its content directly into our App view, we will move it to a new separate HelloPanel view. \
We refer to this using an XMLView tag in the content aggregation of the panel.

## Step 16: Dialogs and Fragments

Fragments are light-weight UI parts (UI subtrees) which can be reused but do not have any controller.

Dialogs are special, because they open on top of the regular app content and thus do not belong to a specific view.

It is a good practice to set a unique ID like helloWorldButton to key controls of your app so that can be identified easily. \
If the attribute `id` is not specified, the OpenUI5 runtime generates unique but changing ID like `__button23` for the control.

## Step 17: Fragment Callbacks

The event handler function is put into the same controller file and it closes the dialog by accessing the internal helper function that returns the dialog.

## Step 18: Icons

We add an icon to the button that opens the dialog. The `sap-icon://` protocol is indicating that an icon from the icon font should be loaded. \
The identifier world is the readable name of the icon in the icon font.

You can look up other icons using the [Icon Explorer](https://sapui5.hana.ondemand.com/sdk/test-resources/sap/m/demokit/iconExplorer/webapp/index.html) tool in the Demo Kit.

## Step 19: Aggregation Binding

JSON is a very lightweight format for storing data and can be directly used as a data source for SAPUI5 applications.

In the **items** aggregation, we define the template for the list that will be automatically repeated for each invoice of our test data.

## Step 22: Custom Formatters

We add a status using the `firstStatus` aggregation to our `ObjectListItem` that will display the status of our invoice. \
The custom formatter function is specified with the reserved property `formatter` of the binding syntax. \
A `"."` in front of the formatter name means that the function is looked up in the controller of the current view. \
There we defined a property `formatter` that holds our formatter functions, so we can access it by `.formatter.statusText`.

Head to [this](https://sapui5.hana.ondemand.com/#/topic/07e4b920f5734fd78fdaa236f26236d8.html) link for more information.

## Step 23: Filtering

In the `onFilterInvoices` function we construct a filter object from the search string that the user has typed in the search field. \
Event handlers always receive an event argument that can be used to access the parameters that the event provides.

In our case the search field defines a parameter query that we access by calling `getParameter(“query”)` on the `oEvent` parameter.

We could also add more filters to the array, if we wanted to search more than one data field.

The filter operator `FilterOperator.Contains` is **not** case-sensitive.

## Step 24: Sorting and Grouping

We add a declarative sorter to our binding syntax.\
As usual, we transform the simple binding syntax to the object notation, specify the path to the data, and now add an additional `sorter` property. \
By default, the sorting is ascending, but you could also add a property `descending` with the value `true` inside the sorter property to change the sorting order.

## Step 25: Remote OData Service

Our component now automatically creates an instance of `sap.ui.model.odata.v2.ODataModel` according to the settings we specified above, and makes it available as a model named `invoice`. \
When you use the `invoiceRemote` data source, the `ODataModel` fetches the data from the real Northwind OData service.

> **ℹ️ Note** \
If you want to have a default model on the component, you can change the name of the model to an empty string in the descriptor file. \
Automatically instantiated models can be retrieved by calling `this.getModel` in the component. In the controllers of component-based apps you can call `this.getView().getModel()` to get the automatically instantiated model. \
For retrieving a named model you have to pass on the model name defined in the descriptor file to `getModel`, that is, in the component you would call `this.getModel("invoice")` to get our automatically generated invoice model that we defined in the descriptor.

If you use a remote URL in your code, for example a remote OData service, such as the publicly available Northwind OData service, the browser may refuse to connect to a remote URL. Due to the same-origin policy, browsers deny AJAX requests to service endpoints in case the service endpoint has a different domain/subdomain, protocol, or port than the app.

Depending on your development environment you have different options to overcome this restriction. For more information, see [Request Fails Due to Same-Origin Policy (Cross-Origin Resource Sharing - CORS)](https://sapui5.hana.ondemand.com/#/topic/5bb388fc289d44dca886c8fa25da466e.html).

## Step 26: Mock Server Configuration

This system is the so-called back-end system that we will now simulate with an SAPUI5 feature called mock server. \
It serves local files, but it simulates a back-end system more realistically than just loading the local data.

Test pages should not be placed in the application root folder but in a subfolder called **test** to clearly separate productive and test coding. \
From this point on, you have two different entry pages: One for the real “connected” app (**index.html**) and one for local testing (**mockServer.html**).

The namespace now points to the folder above (**"../"**), because the `mockServer.html` file is now in a subfolder of the webapp folder. Instead of loading the app component directly, we now call a script `initMockServer.js`.

The metadata file contains information about the service interface. \
The mock server will read this file to simulate the real OData service, and will return the results from our local source files in the proper format so that it can be consumed by the app (either in XML or in JSON format).

## Step 27: Unit Test with QUnit

If you want to learn more about QUnit tests, have a look at our [Testing](https://sapui5.hana.ondemand.com/#/topic/291c9121e6044ab381e0b51716f97f52.html) tutorial, especially [Step 2: A First Unit Test](https://sapui5.hana.ondemand.com/#/topic/b81736e0fcb246efb3b0cf0ca422f8fd.html).

We add a new folder **unit** under the **test** folder and a model subfolder where we will place our formatter unit test. \
The folder structure matches the app structure to easily find the corresponding unit tests.

The formatter file just contains one QUnit module for our formatter function. \
It instantiates our `ResourceBundle` with the localized texts in the `beforeEach` function and destroys it again in the `afterEach` function. \
These functions are called before and after each test is executed.

Since we do not want to test the controller, the view, or the model functionality, we first remove the dependencies by replacing these calls with empty hulls with the help of [SinonJS](https://sinonjs.org/) and its stub method.

Test stubs are functions with pre-programmed behavior. \
They support the full SinonJS test spy API in addition to methods which can be used to alter the stub’s behavior. \
If this part is a bit confusing have a look at the [official SinonJS documentation](https://sinonjs.org/releases/v14/) for test spies or ignore it for now, it will become clear later on.

## Step 28: Integration Test with OPA

Using integration and unit tests and running them consistently in a continuous integration (CI) environment, we can make sure that we don’t accidentally break our app or introduce logical errors in existing code.

If you want to learn more about OPA tests, have a look at our [Testing](https://sapui5.hana.ondemand.com/#/topic/291c9121e6044ab381e0b51716f97f52.html) tutorial, especially [Step 6: A First OPA Test](https://sapui5.hana.ondemand.com/#/topic/1b47457cbe4941ee926317d827517acb.html).

A **journey** consists of a series of integration tests that belong to the same context such as navigating through the app.

The function `opaTest` is the main aspect for defining integration tests with OPA. Its parameters define a test name and a callback function that gets executed with the following OPA5 helper objects to write meaningful tests that read like a user story.

As you can see, the test case reads like a user story, we actually do not need the implementation of the methods yet to understand the meaning of the test case. This approach is called "Behavior Driven Development" or simply BDD and is popular in "Agile Software Development".

## Step 29: Debugging Tools

Luckily, SAPUI5 provides a couple of debugging tools that we can use within the app to check the application logic and the developer tools of modern browsers are also quite good.

[Keyboard Shortcuts for SAPUI5 Tools](https://sapui5.hana.ondemand.com/#/topic/154844c3ac2a4675a37aeb6259a5e034.html)

If you use the Google Chrome browser, you can install the **UI5 Inspector** plugin. \
With this plugin, you can easily debug your SAPUI5- or OpenUI5-based apps. For more information, see **UI5 Inspector**.

Sometimes errors are not as easy to spot and you actually need to debug the JavaScript code with the tools of the browser. \
For performance reasons, the SAPUI5 files are shipped in a minified version, this means that all possible variable names are shortened and comments are removed.

This makes debugging harder because the code is a lot less readable. \
You can load the debug sources by adding the URL parameter `sap-ui-debug=true` or by pressing `Ctrl Shift Alt / Option + P` and selecting **Use Debug Sources** in the dialog box that is displayed. \
After reloading the page, you can see in the **Network tab** of the browser’s developer tools that now a lot of files with the `–dbg` suffix are loaded. \
These are the source code files that include comments and the uncompressed code of the app and the SAPUI5 artifacts.

For a more detailed explanation of the SAPUI5 support tools, go through the [Troubleshooting](https://sapui5.hana.ondemand.com/#/topic/5661952e72df471b932eddc10350c081.html) tutorial.

## Step 30: Routing and Navigation

We specify a routing configuration for our app and create a separate view for each page of the app, then we connect the views by triggering navigation events.

There are three subsections that define the routing and navigation structure of the app
* config
* routes
* targets

In the component initialization method, we now add a call to initialize the router. \
We do not need to instantiate the router manually, it is automatically instantiated based on our **AppDescriptor** configuration and assigned to the component.

Initializing the router will evaluate the current URL and load the corresponding view automatically. \
This is done with the help of the routes and targets that have been configured in the **AppDescriptor**.

In general, one instance of a controller is instantiated for each view that references the controller.

The router identifies the app control with the ID that corresponds to the property `controlId: “app”` in the **AppDescriptor**.

## Step 31: Routing with Parameters

We now add a navigation parameter `invoicePath` to the detail route so that we can hand over the information for the selected item to the detail page. \
Mandatory navigation parameters are defined with curly brackets.

The control instance that has been interacted with can be accessed by the `getSource` method that is available for all SAPUI5 events.

The `bindElement` function is creating a binding context for a SAPUI5 control and receives the model name as well as the path to an item in a configuration object.

## Step 32: Routing Back and History

On the detail page, we tell the control to display a back button by setting the parameter `showNavButton` to `true` and register an event handler that is called when the back button is pressed.

## Conventions

* Name of the root HTML file of the app is `index.html`
* View names are capitalized
* All views are stored in the view folder
* Names of XML views always end with `*.view.xml`
* The default XML namespace is **sap.m**
* Other XML namespaces use the last part of the SAP namespace as alias (for example, **mvc** for **sap.ui.core.mvc**)
* Controller names are capitalized
* Event handlers are prefixed with on
* Controller names always end with `*.controller.js`
* Use Hungarian notation for variable names.
* The resource model for internationalization is called the i18n model.
* The default filename is **i18n.properties**.
* Resource bundle keys are written in (lower) camelCase.
* Resource bundle values can contain parameters like {0}, {1}, {2}, …
  * Never concatenate strings that are translated, always use placeholders.
  * Use Unicode escape sequences for special characters.
* The descriptor file is named **manifest.json**
* Use translatable strings for the title and the description of the app.
* Use the standard SAPUI5 CSS classes for the layout if possible.
* Do not specify colors in custom CSS but use the standard theme-dependent classes instead.
* Private functions and variables should always start with an underscore.
* Always use icon fonts rather than images wherever possible, as they are scalable without quality loss (vector graphics) and do not need to be loaded separately.
* Use data types instead of custom formatters whenever possible.
* Only use expression binding for trivial calculations.
* The **webapp/test** folder contains non-productive code only.
* Mock data and the script to start the **MockServer** are stored in the **webapp/localService** folder.
* All unit tests are placed in the webapp/test/unit folder of the app.
* Files in the test suite end with `*.qunit.html`.
* The `unitTests.qunit.html` file triggers all unit tests of the app.
* A unit test should be written for formatters, controller logic, and other individual functionality.
* All dependencies are replaced by stubs to test only the functionality in scope.
* OPA tests are located in the `webapp/test/integration` folder of the application.
* Use page objects and `journeys` for structuring OPA tests.
* As per SAPUI5 convention uncompressed source files end with `*-dbg.js`
* Define the routing configuration in the descriptor
* Add a path to go back to the parent page when the history state is unclear.

## Framework specifics

* Only instances of `sap.ui.core.Control` or their subclasses can be rendered stand-alone and have a `placeAt` function. \
  Each control extends `sap.ui.core.Element` that can only be rendered inside controls.
* The namespace identifies all resources of the project and has to be unique. \
  If you develop your own application code or controls, you cannot use the namespace prefix **sap**, because this namespace is reserved for SAP resources.
* Use `sap.ui.define` for controllers and all other JavaScript modules to define a global namespace.
* Use `sap.ui.require` for asynchronously loading dependencies but without declaring a namespace, for example code that just needs to be executed, but does not need to be called from other code.
  * Use the name of the artifact to load for naming the function parameters (without namespace).
* The curly brackets {…} indicate that data is taken from the value of the `recipient`'s object name property. This is called **"data binding"**.
* The process of internationalization – in short i18n – is achieved in SAPUI5 by using a special resource model and the standard data binding syntax, but without preceding /.
