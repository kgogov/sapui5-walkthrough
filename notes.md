# Walkthrough notes

## Step 1: Bootstrapping our UI5 application

Before we can do something with SAPUI5, we need to load and initialize it. \
This process of loading and initializing SAPUI5 is called **bootstrapping**.

## Step 2: Controls

SAPUI5 Controls are used to define appearance and behavior of parts of the screen. \
All controls of SAPUI5 have a fixed set of properties, aggregations, and associations for configuration. \
You can find their descriptions in the [Demo Kit](https://sapui5.hana.ondemand.com/#/api).

## Step 3: XML Views

SAPUI5 supports multiple view types (XML, HTML, JavaScript). \
We choose XML as this produces the most readable code and will force us to separate the view declaration from the controller logic.

## Step 4: Controllers

A view does not necessarily need an explicitly assigned controller. \
You do not have to create a controller if the view is just displaying information and no additional functionality is required. \
If a controller is specified, it is instantiated after the view is loaded.

In SAPUI5, resources are often referred to as modules.

We add an init function to the controller. \
`onInit` is one of SAPUI5’s lifecycle methods that is invoked by the framework when the controller is created, similar to a constructor function of a control.

For more information please refer to [this](https://blogs.sap.com/2018/11/12/sapui5-controller-lifecycle-methods-explained/) blog post.

## Step 9: Component Configuration

Components are independent and reusable parts used in SAPUI5 applications. \
This architectural change allows our app to be used in more flexible environments than our static **index.html** page, such as in a surrounding container like the SAP Fiori launchpad.

## Step 10: Descriptor for Applications

All application-specific configuration settings will now further be put in a separate descriptor file called **manifest.json** \
This clearly separates the application coding from the configuration settings and makes our app even more flexible. \
For example, all SAP Fiori applications are realized as components and come with a descriptor file in order to be hosted in the SAP Fiori launchpad.

The content of the **manifest.json** file is a configuration object in JSON format that contains all global application settings and parameters. \
The manifest file is called the descriptor for applications, components, and libraries and is also referred to as “descriptor” or “app descriptor” when used for applications. \
There are three important sections defined by namespaces in the manifest.json file:
* **sap.app**
* **sap.ui**
* **sap.ui5**

Automatic model instantiation is only available as of SAPUI5 version 1.30.

## Step 11: Pages and Panels

After all the work on the app structure it’s time to improve the look of our app. \
We will use two controls from the **sap.m** library to add a bit more "bling" to our UI. You will also learn about control aggregations in this step.

## Step 12: Shell Control as Container

Now we use a shell control as container for our app and use it as our new root element. The shell takes care of visual adaptation of the application to the device’s screen size by introducing a so-called letterbox on desktop screens. \
The app is now run in a shell that limits the app width. \
There are further options to customize the shell, like setting a custom background image or color and setting a custom logo. Check the related [API reference](https://sapui5.hana.ondemand.com/#/api/sap.m.Shell) for more details.

## Step 13: Margins and Paddings

Instead of manually adding CSS to the controls, we will use the standard classes provided by SAPUI5. \
These classes take care of consistent sizing steps, left-to-right support, and responsiveness. \
Margins can be added to all kinds of controls and are available in many different options.

## Step 14: Custom CSS and Theme Colors

Sometimes we need to define some more fine-granular layouts and this is when we can use the flexibility of CSS by adding custom style classes to controls and style them as we like.

⛔️ As stated in the *Compatibility Rules*, the HTML and CSS generated by SAPUI5 is not part of the public API and may change in patch and minor releases. \
If you decide to override styles, you need to test and update your modifications each time SAPUI5 is updated.

In a new style definition file inside the css folder we create our custom classes combined with a custom namespace class.

For a complete list of the available CSS class names, see [CSS Classes for Theme Parameters](https://sapui5.hana.ondemand.com/#/topic/ea08f53503da42c19afd342f4b0c9ec7.html).

## Step 15: Nested Views

Instead of putting the panel and its content directly into our App view, we will move it to a new separate HelloPanel view. \
We refer to this using an XMLView tag in the content aggregation of the panel.

## Step 16: Dialogs and Fragments

Fragments are light-weight UI parts (UI subtrees) which can be reused but do not have any controller.

Dialogs are special, because they open on top of the regular app content and thus do not belong to a specific view.

It is a good practice to set a unique ID like helloWorldButton to key controls of your app so that can be identified easily. \
If the attribute `id` is not specified, the OpenUI5 runtime generates unique but changing ID like `__button23` for the control.

## Step 17: Fragment Callbacks

The event handler function is put into the same controller file and it closes the dialog by accessing the internal helper function that returns the dialog.

## Step 18: Icons

We add an icon to the button that opens the dialog. The `sap-icon://` protocol is indicating that an icon from the icon font should be loaded. \
The identifier world is the readable name of the icon in the icon font.

You can look up other icons using the [Icon Explorer](https://sapui5.hana.ondemand.com/sdk/test-resources/sap/m/demokit/iconExplorer/webapp/index.html) tool in the Demo Kit.

## Step 19: Aggregation Binding

JSON is a very lightweight format for storing data and can be directly used as a data source for SAPUI5 applications.

In the **items** aggregation, we define the template for the list that will be automatically repeated for each invoice of our test data.

## Step 22: Custom Formatters

We add a status using the `firstStatus` aggregation to our `ObjectListItem` that will display the status of our invoice. \
The custom formatter function is specified with the reserved property `formatter` of the binding syntax. \
A `"."` in front of the formatter name means that the function is looked up in the controller of the current view. \
There we defined a property `formatter` that holds our formatter functions, so we can access it by `.formatter.statusText`.

Head to [this](https://sapui5.hana.ondemand.com/#/topic/07e4b920f5734fd78fdaa236f26236d8.html) link for more information.

## Step 23: Filtering

In the `onFilterInvoices` function we construct a filter object from the search string that the user has typed in the search field. \
Event handlers always receive an event argument that can be used to access the parameters that the event provides.

In our case the search field defines a parameter query that we access by calling `getParameter(“query”)` on the `oEvent` parameter.

We could also add more filters to the array, if we wanted to search more than one data field.

The filter operator `FilterOperator.Contains` is **not** case-sensitive.

## Step 24: Sorting and Grouping

We add a declarative sorter to our binding syntax.\
As usual, we transform the simple binding syntax to the object notation, specify the path to the data, and now add an additional `sorter` property. \
By default, the sorting is ascending, but you could also add a property `descending` with the value `true` inside the sorter property to change the sorting order.

## Conventions

* Name of the root HTML file of the app is `index.html`
* View names are capitalized
* All views are stored in the view folder
* Names of XML views always end with `*.view.xml`
* The default XML namespace is **sap.m**
* Other XML namespaces use the last part of the SAP namespace as alias (for example, **mvc** for **sap.ui.core.mvc**)
* Controller names are capitalized
* Event handlers are prefixed with on
* Controller names always end with `*.controller.js`
* Use Hungarian notation for variable names.
* The resource model for internationalization is called the i18n model.
* The default filename is **i18n.properties**.
* Resource bundle keys are written in (lower) camelCase.
* Resource bundle values can contain parameters like {0}, {1}, {2}, …
  * Never concatenate strings that are translated, always use placeholders.
  * Use Unicode escape sequences for special characters.
* The descriptor file is named **manifest.json**
* Use translatable strings for the title and the description of the app.
* Use the standard SAPUI5 CSS classes for the layout if possible.
* Do not specify colors in custom CSS but use the standard theme-dependent classes instead.
* Private functions and variables should always start with an underscore.
* Always use icon fonts rather than images wherever possible, as they are scalable without quality loss (vector graphics) and do not need to be loaded separately.
* Use data types instead of custom formatters whenever possible.
* Only use expression binding for trivial calculations.

## Framework specifics

* Only instances of `sap.ui.core.Control` or their subclasses can be rendered stand-alone and have a `placeAt` function. \
  Each control extends `sap.ui.core.Element` that can only be rendered inside controls.
* The namespace identifies all resources of the project and has to be unique. \
  If you develop your own application code or controls, you cannot use the namespace prefix **sap**, because this namespace is reserved for SAP resources.
* Use `sap.ui.define` for controllers and all other JavaScript modules to define a global namespace.
* Use `sap.ui.require` for asynchronously loading dependencies but without declaring a namespace, for example code that just needs to be executed, but does not need to be called from other code.
  * Use the name of the artifact to load for naming the function parameters (without namespace).
* The curly brackets {…} indicate that data is taken from the value of the `recipient`'s object name property. This is called **"data binding"**.
* The process of internationalization – in short i18n – is achieved in SAPUI5 by using a special resource model and the standard data binding syntax, but without preceding /.
